\chapter{Implementation}
\label{chap:Implementation}

\section{Broker Implementation}
\label{sec:Broker Implementation}

\todo[inline]{High level overview of the broker architecture (blocks/channels/message flows etc.), as well as datastructures/algorithms used}

\subsection{Connection Manager}
\label{sub:Connection Manager}

\todo[inline]{Overview of the connection manager (TCP/UDP connections etc.)}

\subsection{Message Storage}
\label{sub:Message Handlers}

In the event that, for whatever reason, a client is not ready to accept a
message when it arrives - this message must be buffered up in a datastructure of
some kind, until delivery is possible. There are a number of different
datastructures that could be used - each with its own pros and cons. \\

As mentioned in Section~\ref{sub:pubsub}, message brokers typically support a
number of different delivery patterns, the two most common of which are Queues
(Section~\ref{sub:queues}) and Topics (Section~\ref{sub:topics}). The backing
datastructures used for each are explored below. \\

Queues require that messages are delivered in the order they are pushed onto the
queue, and that each message is delivered to a single consumer - so any backing
datastructure must support this. The simplest method of representing a queue of
messages, would be an array. New messages are inserted into the first unoccupied
slot in the array, and messages are read front-to-back, in a \gls{fifo} fashion.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{\textwidth}
    \centering
    \input{figures/queueArray}
    \caption{Messages are read from the head of the queue ($h$)}
    \label{fig:tikz:queueArrayInitial}
  \end{subfigure}

  \begin{subfigure}[b]{\textwidth}
    \centering
    \input{figures/queueArrayHeadRead}
    \caption{The array is shuffled down}
    \label{fig:tikz:queueArrayHeadRead}
  \end{subfigure}

  \begin{subfigure}[b]{\textwidth}
    \centering
    \input{figures/queueArrayPostShuffle}
    \caption{The next message is now ready to be read}
    \label{fig:tikz:queueArrayPostShuffle}
  \end{subfigure}
  \caption{Reading a message from an array-based queue}
  \label{fig:tikz:queueArray}
\end{figure}

However, there are several disadvantages of this approach. In most programming
languages, arrays are fixed-size datastructures - but a message queue may
receive an undefined number  of messages to buffer. This fixed size also leads
to inefficiencies when the queue is empty - as space for the array will remain
allocated. When a message is read from the backing store - the entire array must
be '\textit{shuffled}' down, ready for the next read, as demonstrated in
Figure~\ref{fig:tikz:queueArray}. This memory copy is expensive - especially if
the array is large, full of elements, and
uncached.\footnote{\url{https://gist.github.com/jboner/2841832}}\\

An alternative method of representing an in-memory-queue, is a linked list.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{\textwidth}
    \centering
    \input{figures/queueLinkedList}
    \caption{Messages are read from the head of the queue ($h$)}
    \label{fig:tikz:queueLinkedList}
  \end{subfigure}

  \begin{subfigure}[b]{\textwidth}
    \centering
    \input{figures/queueLinkedListHeadRead}
    \caption{Head moves, and read nodes are marked for garbage collection}
    \label{fig:tikz:queueLinkedListHeadRead}
  \end{subfigure}

  \begin{subfigure}[b]{\textwidth}
    \centering
    \input{figures/queueLinkedListGCRun}
    \caption{At some point in the future (depending on memory pressure),
             the Garbage Collector will clean up the read messages}
    \label{fig:tikz:queueLinkedListGCRun}
  \end{subfigure}
  \caption{Reading a message from an array-based queue}
  \label{fig:tikz:queueLinkedListGCRun}
\end{figure}

\todo[inline]{Message storage/datastructures etc.}

\subsection{Message Shipper}
\label{sub:Message Shipper}

\todo[inline]{Message delivery/queue/topic behavior}

\subsection{Metrics Manager}
\label{sub:Metrics Manager}

\todo[inline]{Metric format/serialization. How do we ensure minimal CPU usage}

\section{Presentation Interface}
\label{sec:Presentation Interface}

\todo[inline]{Screenshots/high-level description}

\subsection{Graphite/Grafana}
\label{sub:Graphite/Grafana}

\todo[inline]{Architecture}

\subsection{Docker}
\label{sub:Docker}

\todo[inline]{Overview and Dockerfile description}

\section{Utilities}
\label{sec:Utilities}

\todo[inline]{Python benchmark code walkthrough}

\subsection{Configuration}
\label{sub:Configuration}

\todo[inline]{Specifics of command-line flag/config file implementation}

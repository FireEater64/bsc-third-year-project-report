\chapter{Design}
\label{chap:Design}

\section{Project philosophy}
\label{sec:Project philosophy}

One of the learning objectives for this project, was to discover and utilize
\gls{foss} technologies wherever possible, as well as give back to the
\gls{foss} community. As such, all of the tooling used in the production of the
project, as well as the project itself were open-source. The project itself is
published under the MIT License, which allows anyone to "use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software",
without restriction.

\section{Presentation interface}
\label{sec:presentation}

As a (primarily) middleware project - coming up with a compelling presentation
interface is crucial to allowing people to engage with the software, as well as
providing monitoring capabilities, should it be deployed in a production
environment. Broker metrics such as:

\begin{itemize}
  \item Messages/second (broken down by topic)
  \item (Average) End-to-end latency for each message
  \item Memory/Disk usage
  \item CPU utilisation
  \item Pending messages
  \item Unacknowledged messages
  \item Total messages processed
\end{itemize}

And client metrics such as:

\begin{itemize}
  \item Messages sent
  \item Messages received
  \item Messages lost
\end{itemize}

Should be easily accessible, and visualised. The presentation and metrics
collection for gamq consists of the following components:

\subsection{StatsD}
\label{sub:StatsD}

StatsD is an open-source statistics daemon, written by developers at
Etsy\footnote{\url{https://www.etsy.com/uk/}} in 2010\cite{statsd}, and which
has seen widespread adoption by infrastructure teams ever since. StatsD aims to
define a simple protocol (Listing~\ref{lst:statsdSchema}) for sending statistics
over the network, and make it simple to aggregate and store those metrics for
real-time analysis. StatsD can differentiate between metrics of different types:

\begin{listing}
  \centering
  \mintinline{text}{metricname:1|c}
  \caption{A simple counter metric, exactly as it would appear inside a network packet}
  \label{lst:statsdSchema}
\end{listing}

\begin{description}
  \item[Counters] A simple counter that can be incremented or decremented. An
  example use case could be the number of messages sent through a broker.
  \item[Timing] The amount of time taken to complete a task. An example could be
  the amount of time taken to process a message.
  \item[Gauges] An arbitrary value, stored until it is superseded by a new
  value. An example of this could be the number of connections open to the
  broker at a single point in time.
\end{description}

These packets can be sent over the network as either TCP or UDP packets. Packets
can contain multiple metrics, separated with newline characters
(Listing~\ref{lst:statsdMultiplePackets}), which can greatly improve the
efficiency of the transfer, as the size of each metric (the order of a few
bytes) is far below the maximum capacity of a single packet.\footnote{The
typical \gls{mtu} of Ethernet networks is ~1500 bytes} Gamq uses the UDP
protocol by default (although this is configurable, see
Section~\ref{sec:Configuration} for details), as the cost of sending UDP packets
is very low cost when compared to TCP, and we do not require the deliverability
guarantees of TCP (metrics are non-critical). Metrics are typically sent over a
\gls{lan}, where packet loss is usually quite low. In the event that is it not,
but the packet loss is uniform, the loss of some metrics should not affect the
overall data trend.

\begin{listing}
  \centering
  \mintinline{text}{gorets:1|c\nglork:320|ms\ngaugor:333|g\nuniques:765|s}
  \caption{Multiple metrics in a single packet}
  \label{lst:statsdMultiplePackets}
\end{listing}

\subsection{InfluxDB}
\label{sub:InfluxDB}

InfluxDB is an open-source, NoSQL database, optimised for the storage and
retrieval of \gls{time-series data}. Influx is part of a family of databases
designed to store (amongst other things) a large amount of metrics data at very
high speed (the order of millions of events per second), which also includes
\href{http://graphite.wikidot.com/}{Graphite} and
\href{http://opentsdb.net/}{OpenTSDB}. InfluxDB was chosen for this project due
to its maturity (compared to OpenTSDB) and performance (compared to
Graphite/Carbon).

\subsection{Grafana}
\label{sub:Grafana}

\href{http://grafana.org/}{Grafana} is an open-source visualisation tool for
\gls{time-series data}, typically that which is produced by Internet
infrastructure and application analytics. Developed by a consortium of Internet
companies as a modern replacement for the previously popular
\href{https://github.com/graphite-project/graphite-web}{Graphite-Web} project.
Grafana can visualise \gls{time-series data} from a variety of data-sources,
such as the ElasticSearch, the aforementioned Graphite and, most importantly,
InfluxDB.

\missingfigure{Grafana screenshot}

\subsection{Docker}
\label{sub:dockerDesign}

Gamq is designed to send StatsD messages (Section~\ref{sub:StatsD}) across the
network. In a production environment, these would be sent to the above software
stack, running on a separate server in the datacenter. In a development
environment, the metrics stack could be run on a development server, or the
developers local machine. The configured stack should therefore be as portable
as possible, to make development as simple as possible. \todo{Docker description}

\section{Configuration}
\label{sec:Configuration}

As with most pieces of software - there are situations where the default
behaviour of a message broker requires adjustment to suit its operating
environment. One example of this is the network port that the broker operates
on, and which other applications will connect to in order to exchange messages.
Whilst the default port (48879\footnote{A number chosen due to its memorable
hexadecimal representation: \texttt{0xBEEF}} in the case of this broker) may be
suitable in most cases, since no other 'well-known' applications use that
particular
port.\footnote{\url{https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers}}.

\subsection{Command-line configuration}
\label{sub:Command-line configuration}

A number of these configurable parameters make sense to expose as command-line
parameters, specified at application start time. The available parameters can be
exposed using the \texttt{--help} parameter, the output of which can be seen in
Listing~\ref{lst:gamqHelpOutput}

\begin{listing}[ht]
  \centering
  \RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
  \inputminted{bash}{code/gamqHelpOutput}
  \caption{Output of running the broker with the --help flag}
  \label{lst:gamqHelpOutput}
\end{listing}

\subsection{File-based configuration}
\label{sub:File-based configuration}

Whilst specifying arguments on the command line gives flexibility, there are
certain options that, whilst configurable, are either too numerous, or change
too infrequently to justify command-line flags. One major example of this is the
log configuration for the broker - an \gls{xml} file specifying specifying the
format, and location of messages logged using the
\href{https://github.com/cihub/seelog}{Seelog} library. An example log
configuration can be seen in Listing~\ref{lst:seelogConfig}.

\begin{listing}[ht]
  \centering
  \RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
  \inputminted{xml}{code/gamq/config/logconfig.xml}
  \caption{Example Seelog configuration file for gamq.}
  \label{lst:seelogConfig}
\end{listing}

\section{Code Structure}
\label{sec:codestructure}

\todo[inline]{Box-level overview of how the code is structured/how messages
flow through the broker}

\section{Protocol Design}
\label{sec:protocol}

As a piece of network-connected software - a clear, well-defined protocol is
essential to allow other networked applications to interact with the messaging
broker. Although a simple protocol is used in the current implementation, the
message decoding logic is designed to be somewhat modular, allowing for
additional protocols to easily be supported. The NATS message
protocol\cite{natsProtocol} served as an inspiration for gamq - as it showed it
was possible for text-based protocols to be as performant as customised binary
protocols, and had a slew of other benfits, such as human-readability, and ease
of debugging.

The gamq protocol defines several commands, which can be seen in
Table~\ref{tab:protocol}. These commands are all delimited by \verb|\r\n|, which
is the telnet standard. The two most frequently used commands (\emph{PUB} and
\emph{SUB}) are intentionally short to reduce the overhead required to send them
over the wire - which is especially important as message rate increases. Note
that whilst all commands listed in the following sections are demonstrated using
telnet, in reality they would be given programatically, by software wishing to
send messages to the broker (An example of which can be seen in
\ref{chap:benchmarkCode})

\begin{table}[H]
\centering
\caption{The gamq protocol commands}
\label{tab:protocol}
\begin{tabular}{|l|}
\hline
Command \\ \hline
\verb|HELP\r\n|                           \\
\verb|PUB <queue>\r\n <message>\r\n.\r\n| \\
\verb|SUB <queue>\r\n|                    \\
\verb|PINGREQ\r\n|                        \\
\verb|DISCONNECT\r\n|                     \\
\verb|SETACK <on/off>\r\n|                \\ \hline
\end{tabular}
\end{table}

\subsection{HELP}
\label{sub:helpCommand}

\begin{listing}[H]
  \centering
  \RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
  \inputminted{bash}{code/gamqHelpOutputTelnet}
  \caption{Output from the gamq HELP command}
  \label{lst:gamqHelpTelnet}
\end{listing}

Print the help message (as seen in Listing~\ref{lst:gamqHelpTelnet})

\subsection{PUB}
\label{sub:pubCommand}

\begin{listing}[H]
  \centering
  \RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
  \inputminted{bash}{code/gamqPubOutput}
  \caption{Publishing a message to gamq}
  \label{lst:gamqPubTelnet}
\end{listing}

Send the given message, to the given queue. In Listing~\ref{lst:gamqPubTelnet},
we are publishing a message to the queue 'abc'. Note that messages can span
multiple lines, and are terminated with a single '.', on a line by itself.

\subsection{SUB}
\label{sub:subCommand}

\begin{listing}[H]
  \centering
  \RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
  \inputminted{bash}{code/gamqSubOutput}
  \caption{Subscribing to a queue/topic in gamq}
  \label{lst:gamqSubTelnet}
\end{listing}

Subscribe to messages posted on the named queue (see Section~\ref{sub:pubsub}).
Note that in Listing~\ref{lst:gamqSubTelnet}, when we subscribe to the queue
'abc', we receive the message sent to that queue in
Section~\ref{sub:pubCommand}.

\subsection{PINGREQ}
\label{sub:pingreqCommand}

\begin{listing}[H]
  \centering
  \RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
  \inputminted{bash}{code/gamqPingreqOutput}
  \caption{Pinging the broker through telnet}
  \label{lst:gamqPingreqTelnet}
\end{listing}

Ask the broker to return a 'PINGRESP' message. This can be used to check that
the connection to the broker is active, and the broker is responding to
messages. Clients should send this at regular intervals.

\subsection{DISCONNECT}
\label{sub:disconnectCommand}

\begin{listing}[H]
  \centering
  \RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
  \inputminted{bash}{code/gamqDisconnectOutput}
  \caption{Closing a connection to the broker}
  \label{lst:gamqDisconnectTelnet}
\end{listing}

Unsubscribe from all subscribed queues, and close the connection to the broker.
Whilst the client can achieve the same effect by simply closing its side of a
TCP connection\todo{\gls{tcp}/\gls{udp} section}, since \gls{udp} is a connectionless protocol, it
requires an explicit disconnect message (as in
Listing~\ref{lst:gamqDisconnectTelnet})

\subsection{SETACK}
\label{sub:setackCommand}

\begin{listing}[H]
  \centering
  \RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
  \inputminted{bash}{code/gamqSetackOutput}
  \caption{Demonstrating the effect of the SUBACK command}
  \label{lst:gamqSubackTelnet}
\end{listing}

Turn the explicit acknowledgement of messages on/off (As demonstrated in
Listing~\ref{lst:gamqSubackTelnet}). Clients can use the acknowledgement to
detect potentially lost messages using a timout, and optionally retransmit the
lost message if at-least-once semantics (Section~\ref{sub:failureHandling}) are
required. Explicitly acknowledging messages (as opposed to relying on built in
\gls{tcp} error correction) can have a significant overhead, but can also
dramatically reduce the number of lost messages when using a protocol with no
built-in error correction(\gls{udp}).
